# -*- coding: utf-8 -*-
## Add snippets at EoF
## Separate them with \n\n; the last also.
f()= ok

len (L) | is_list(L)  = length(L)
len (T) | is_tuple(T) = size(T)

f()= thiS() W=ill tot:ally(W + ork)
g()= i-ll(give) my:hand() to_cut

length ([])    = 0
length ([_|T]) = 1 + :(T)  #% ‘:’ references the currently defined function, here: ‘length’

#5
f () =
    case orddict:find(Node, Nodes) of
        {ok, Ref} -> {down, node, Ref}
        {ok, WrongRef} | is_reference(WrongRef) -> 'not the one'
        error ->     {ignore, not_monitored, FD}
    end

'f' () =
    receive
#%       {'ok', Ref} -> 'do_somth'('arg1', 2) {'down', 'node', Ref}
        {'ok', WrongRef} when 'is_reference'(WrongRef) -> 'smth'() 'not the one'
        'error' ->     {'ignore', 'not_monitored', FD}
    end

t () =
    try Expr
    catch
        throw:Term -> Term
        exit:Reason -> {'EXIT',Reason}
        error:Reason -> {'EXIT',{Reason,erlang:get_stacktrace()}}
    end

i (Arg1) =
    if not Arg1 false else false end

len (A) =
    case A of
        L when is_list(L) ->
            length(L)
        T | is_tuple(T) ->
            size(T)
    end

#10
p (Str) =
    F = fun io:format("~p\n")/1
    F(Str)

b () =
    begin
        do()
        some()
        stuff
    end

p&to_list (Arg) =
    case Arg of
        T | is_tuple(T) ->  [p(X) X | X <~ T]
        L | is_list(L) ->   [p(X) X | X <- L]
        B | is_binary(B) -> [p(X) X | X <= B]
    end

map (F, A) | is_tuple(A) = {F(X) | X <~ A}

try…catch () =
    try bla() Expression of
        SuccessfulPattern1 ->
            Expression1
        SuccessfulPattern2 ->
            Expression2
    catch
        TypeOfError:ExceptionPattern1 ->
            Expression3
        TypeOfError:ExceptionPattern2 ->
            Expression4
    end

#15
'π' () = 3.1415926535

brilliant! () =  << case X of Z | m(Z) -> 0 Y -> 1 end | X <~ _>>

i-am-impressed () =
    work()
    try
        talk()
        _Knight = "None shall Pass!"
        _Doubles = [2*N | N <- [1..100]]
        throw(up)
        _WillReturnThis = tequila
    catch
        Exception:Reason -> {caught, Exception, Reason}
    end

export a/0 b/1 c/234

f()= {2..3} [-6..18] [g()-2..Max]

#20
f()= [1|[2|[3|[]]]]

f()= fun (Thu) -> gaim end

many_args (A, [H|T], "str", -2) = ok

fun_clauses () =
    fun (123) -> "123"
        (231) -> deux-trois-un
        (stop) ->
            bla(1, 2, B, [$*])
            babebibobu()
            case do() of
                hammer -> lel() so_funny
                _ -> something
            end
    end

f() = case asd of a -> a s -> smth (d) -> ah-ah! end

#25
len :: (list()) -> pos_integer() | 0
len (L) | is_list(L)  = length(L)

len :: (<list>) -> <pos_integer>
len (L) = length(L)
#% len :: (‹tuple›) -> ‹pos_integer›
len (T) when is_tuple(T) = size(T)

'!' (0) = 1
'!' :: (N) -> M when N::<pos_integer> M::<pos_integer>
'!' (N) = N * :(N - 1)

'!' :: () -> fun((N) -> N) when N::pos_integer()
'!' () =
    fun (0) -> 1
        (N) when N > 0 ->
            N * :(N - 1) #% ‘:’ also works on funs.
    end

flat.map (Fun, List) =
    (fun append/1 . fun map/2) (Fun, List)

#30
flatmap /2 =
    fun append/1 . fun map/2

f /1 =
    fun (0) -> 1
        (N) -> N * :(N - 1)
    end

f()= [ (a()):loop() ]

f()= A = B = C = d

zip :: ([<term>], [<term>]) -> [{<term>,<term>}]
## <=> zip :: lists:zip/2
zip ([X|Xs], [Y|Ys]) =
    [{X',Y'} | X' <- [X|Xs]
             | Y' <- [Y|Ys]]
    # <=> [{X,Y} | :(Xs, Ys)]
zip ([], []) = [] # Using a list comprehension implementation, this line is useless.
# However, it shows that the spec only applies to the first fun_clause.
# However, a warning should be thrown as the second fun_clause is useless.

#35
fizz_buzz (N) =
    [case {X rem 3, X rem 5} of
        {0, 0} -> fizzbuzz
        {0, _} -> fizz
        {_, 0} -> buzz
        {_, _} -> X
     end | X <- [1..N]]

f()= string:sub_string(OptStr, P, P + 2) >= "3.4"

export start/1,2

verify_int (Int, Max) =
    false || verify_strict_int(Int) && verify_strict_int(Max) && Int =< Max

factorial' /1 =
  fun
    (f ) -> fun :/1
    (f') -> fun :()/1
    (0) -> 1
    (N) when N > 0 -> N * :(N -1)
    (f24) -> fun :(4)/0
    (___) ->     :(4)
  end

#40
f()=  fun io:format("~p\n")/1 (dg)/0
f()= (fun io:format("~p\n")/1)(dg)/0

f()= fun (fun io:format("~p\n")/1)(dg)/0

import map/2 foreach/2 from lists

f()= # Integers
    A = 10
    B = -234
    C = 16#AB10F
    D = 2#110111010
    E = $A
     # Floats
    F = 17.368
    G = -56.654
    H = 12.34E-10

f()= ok = a:b()

#45
import ## Depends on 2 versions of same package:
    "github.com/anon42/app1" master
    "github.com/anon42/app1" v1.2
    "bitbucket.org/user2/repo2" master
export main/0
main () =
    ok = app2:bla(bla, bla)
    app1:master:app1:f()
    app1:v1.2  :app1:f()

f($char) = $c

f()= # _ separating digits
    1_000
    1_23_777
    1_00#9_999_957
    10.000_001E-2_345

f :: () -> <<_:Integer, _:_*OtherInteger>>
f()= <<42, 3:2, g():(h()), 1+2:3/ba be bi>>

my_other_function :: (‹names›, ‹places›) → ‹atom›
my_other_function (Names, Places) =
  R1 = ø(Ø, Ça, Names)
  R2 = µ(Ð, Æ, Places)
  if R1 ≥ R2 ok else ko end

